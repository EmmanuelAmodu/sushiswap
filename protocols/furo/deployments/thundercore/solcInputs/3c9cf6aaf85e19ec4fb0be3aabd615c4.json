{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@rari-capital/solmate/src/tokens/ERC721.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity >=0.8.0;\n\n/// @notice Modern, minimalist, and gas efficient ERC-721 implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\n/// @dev Note that balanceOf does not revert if passed the zero address, in defiance of the ERC.\nabstract contract ERC721 {\n    /*///////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Transfer(address indexed from, address indexed to, uint256 indexed id);\n\n    event Approval(address indexed owner, address indexed spender, uint256 indexed id);\n\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /*///////////////////////////////////////////////////////////////\n                          METADATA STORAGE/LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    string public name;\n\n    string public symbol;\n\n    function tokenURI(uint256 id) public view virtual returns (string memory);\n\n    /*///////////////////////////////////////////////////////////////\n                            ERC721 STORAGE                        \n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => uint256) public balanceOf;\n\n    mapping(uint256 => address) public ownerOf;\n\n    mapping(uint256 => address) public getApproved;\n\n    mapping(address => mapping(address => bool)) public isApprovedForAll;\n\n    /*///////////////////////////////////////////////////////////////\n                              CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    constructor(string memory _name, string memory _symbol) {\n        name = _name;\n        symbol = _symbol;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function approve(address spender, uint256 id) public virtual {\n        address owner = ownerOf[id];\n\n        require(msg.sender == owner || isApprovedForAll[owner][msg.sender], \"NOT_AUTHORIZED\");\n\n        getApproved[id] = spender;\n\n        emit Approval(owner, spender, id);\n    }\n\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        isApprovedForAll[msg.sender][operator] = approved;\n\n        emit ApprovalForAll(msg.sender, operator, approved);\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        require(from == ownerOf[id], \"WRONG_FROM\");\n\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(\n            msg.sender == from || msg.sender == getApproved[id] || isApprovedForAll[from][msg.sender],\n            \"NOT_AUTHORIZED\"\n        );\n\n        // Underflow of the sender's balance is impossible because we check for\n        // ownership above and the recipient's balance can't realistically overflow.\n        unchecked {\n            balanceOf[from]--;\n\n            balanceOf[to]++;\n        }\n\n        ownerOf[id] = to;\n\n        delete getApproved[id];\n\n        emit Transfer(from, to, id);\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        bytes memory data\n    ) public virtual {\n        transferFrom(from, to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function supportsInterface(bytes4 interfaceId) public pure virtual returns (bool) {\n        return\n            interfaceId == 0x01ffc9a7 || // ERC165 Interface ID for ERC165\n            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721\n            interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _mint(address to, uint256 id) internal virtual {\n        require(to != address(0), \"INVALID_RECIPIENT\");\n\n        require(ownerOf[id] == address(0), \"ALREADY_MINTED\");\n\n        // Counter overflow is incredibly unrealistic.\n        unchecked {\n            balanceOf[to]++;\n        }\n\n        ownerOf[id] = to;\n\n        emit Transfer(address(0), to, id);\n    }\n\n    function _burn(uint256 id) internal virtual {\n        address owner = ownerOf[id];\n\n        require(ownerOf[id] != address(0), \"NOT_MINTED\");\n\n        // Ownership check above ensures no underflow.\n        unchecked {\n            balanceOf[owner]--;\n        }\n\n        delete ownerOf[id];\n\n        delete getApproved[id];\n\n        emit Transfer(owner, address(0), id);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                       INTERNAL SAFE MINT LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function _safeMint(address to, uint256 id) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, \"\") ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n\n    function _safeMint(\n        address to,\n        uint256 id,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, id);\n\n        require(\n            to.code.length == 0 ||\n                ERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data) ==\n                ERC721TokenReceiver.onERC721Received.selector,\n            \"UNSAFE_RECIPIENT\"\n        );\n    }\n}\n\n/// @notice A generic interface for a contract which properly accepts ERC721 tokens.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/tokens/ERC721.sol)\ninterface ERC721TokenReceiver {\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 id,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@sushiswap/core/contracts/uniswapv2/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.5.0;\n\ninterface IERC20Uniswap {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n}\n"
    },
    "@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Callee.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.5.0;\n\ninterface IUniswapV2Callee {\n    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;\n}\n"
    },
    "@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n    function migrator() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n    function setMigrator(address) external;\n}\n"
    },
    "@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.5.0;\n\ninterface IUniswapV2Pair {\n    event Approval(address indexed owner, address indexed spender, uint value);\n    event Transfer(address indexed from, address indexed to, uint value);\n\n    function name() external pure returns (string memory);\n    function symbol() external pure returns (string memory);\n    function decimals() external pure returns (uint8);\n    function totalSupply() external view returns (uint);\n    function balanceOf(address owner) external view returns (uint);\n    function allowance(address owner, address spender) external view returns (uint);\n\n    function approve(address spender, uint value) external returns (bool);\n    function transfer(address to, uint value) external returns (bool);\n    function transferFrom(address from, address to, uint value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n    function nonces(address owner) external view returns (uint);\n\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    event Mint(address indexed sender, uint amount0, uint amount1);\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint amount0In,\n        uint amount1In,\n        uint amount0Out,\n        uint amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\n    function factory() external view returns (address);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n    function price0CumulativeLast() external view returns (uint);\n    function price1CumulativeLast() external view returns (uint);\n    function kLast() external view returns (uint);\n\n    function mint(address to) external returns (uint liquidity);\n    function burn(address to) external returns (uint amount0, uint amount1);\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n    function skim(address to) external;\n    function sync() external;\n\n    function initialize(address, address) external;\n}"
    },
    "contracts/base/FuroStream.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.10;\n\nimport \"../interfaces/IFuroStream.sol\";\n\n\n// Use the FuroStreamRouter to create Streams and do not create streams directly.\n\ncontract FuroStream is\n    IFuroStream,\n    ERC721(\"Furo Stream\", \"FUROSTREAM\"),\n    Multicall,\n    BoringOwnable\n{\n    IBentoBoxMinimal public immutable bentoBox;\n    address public immutable wETH;\n\n    uint256 public streamIds;\n\n    address public tokenURIFetcher;\n\n    mapping(uint256 => Stream) public streams;\n\n    // custom errors\n    error NotSenderOrRecipient();\n    error InvalidStartTime();\n    error InvalidEndTime();\n    error InvalidWithdrawTooMuch();\n    error NotSender();\n    error Overflow();\n\n    constructor(IBentoBoxMinimal _bentoBox, address _wETH) {\n        bentoBox = _bentoBox;\n        wETH = _wETH;\n        streamIds = 1000;\n        _bentoBox.registerProtocol();\n    }\n\n    function setTokenURIFetcher(address _fetcher) external onlyOwner {\n        tokenURIFetcher = _fetcher;\n    }\n\n    function tokenURI(uint256 id) public view override returns (string memory) {\n        return ITokenURIFetcher(tokenURIFetcher).fetchTokenURIData(id);\n    }\n\n    function setBentoBoxApproval(\n        address user,\n        bool approved,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable override {\n        bentoBox.setMasterContractApproval(\n            user,\n            address(this),\n            approved,\n            v,\n            r,\n            s\n        );\n    }\n\n    function createStream(\n        address recipient,\n        address token,\n        uint64 startTime,\n        uint64 endTime,\n        uint256 amount, /// @dev in token amount and not in shares\n        bool fromBentoBox\n    )\n        external\n        payable\n        override\n        returns (uint256 streamId, uint256 depositedShares)\n    {\n        if (startTime < block.timestamp) revert InvalidStartTime();\n        if (endTime <= startTime) revert InvalidEndTime();\n\n        depositedShares = _depositToken(\n            token,\n            msg.sender,\n            address(this),\n            amount,\n            fromBentoBox\n        );\n\n        streamId = streamIds++;\n\n        _mint(recipient, streamId);\n\n        streams[streamId] = Stream({\n            sender: msg.sender,\n            token: token == address(0) ? wETH : token,\n            depositedShares: uint128(depositedShares), // @dev safe since we know bento returns u128\n            withdrawnShares: 0,\n            startTime: startTime,\n            endTime: endTime\n        });\n\n        emit CreateStream(\n            streamId,\n            msg.sender,\n            recipient,\n            token,\n            depositedShares,\n            startTime,\n            endTime,\n            fromBentoBox\n        );\n    }\n\n    function withdrawFromStream(\n        uint256 streamId,\n        uint256 sharesToWithdraw,\n        address withdrawTo,\n        bool toBentoBox,\n        bytes calldata taskData\n    ) external override returns (uint256 recipientBalance, address to) {\n        address recipient = ownerOf[streamId];\n        if (msg.sender != streams[streamId].sender && msg.sender != recipient) {\n            revert NotSenderOrRecipient();\n        }\n        Stream storage stream = streams[streamId];\n        (, recipientBalance) = _streamBalanceOf(stream);\n        if (recipientBalance < sharesToWithdraw)\n            revert InvalidWithdrawTooMuch();\n        stream.withdrawnShares += uint128(sharesToWithdraw);\n\n        if (msg.sender == recipient && withdrawTo != address(0)) {\n            to = withdrawTo;\n        } else {\n            to = recipient;\n        }\n\n        _transferToken(\n            stream.token,\n            address(this),\n            to,\n            sharesToWithdraw,\n            toBentoBox\n        );\n\n        if (taskData.length != 0 && msg.sender == recipient)\n            ITasker(to).onTaskReceived(taskData);\n\n        emit Withdraw(\n            streamId,\n            sharesToWithdraw,\n            withdrawTo,\n            stream.token,\n            toBentoBox\n        );\n    }\n\n    function cancelStream(uint256 streamId, bool toBentoBox)\n        external\n        override\n        returns (uint256 senderBalance, uint256 recipientBalance)\n    {\n        address recipient = ownerOf[streamId];\n        if (msg.sender != streams[streamId].sender && msg.sender != recipient) {\n            revert NotSenderOrRecipient();\n        }\n        Stream memory stream = streams[streamId];\n        (senderBalance, recipientBalance) = _streamBalanceOf(stream);\n\n        delete streams[streamId];\n\n        _transferToken(\n            stream.token,\n            address(this),\n            recipient,\n            recipientBalance,\n            toBentoBox\n        );\n        _transferToken(\n            stream.token,\n            address(this),\n            stream.sender,\n            senderBalance,\n            toBentoBox\n        );\n\n        emit CancelStream(\n            streamId,\n            senderBalance,\n            recipientBalance,\n            stream.token,\n            toBentoBox\n        );\n    }\n\n    function getStream(uint256 streamId)\n        external\n        view\n        override\n        returns (Stream memory)\n    {\n        return streams[streamId];\n    }\n\n    function streamBalanceOf(uint256 streamId)\n        external\n        view\n        override\n        returns (uint256 senderBalance, uint256 recipientBalance)\n    {\n        return _streamBalanceOf(streams[streamId]);\n    }\n\n    function _streamBalanceOf(Stream memory stream)\n        internal\n        view\n        returns (uint256 senderBalance, uint256 recipientBalance)\n    {\n        if (block.timestamp <= stream.startTime) {\n            senderBalance = stream.depositedShares;\n            recipientBalance = 0;\n        } else if (stream.endTime <= block.timestamp) {\n            recipientBalance = stream.depositedShares - stream.withdrawnShares;\n            senderBalance = 0;\n        } else {\n            uint64 timeDelta = uint64(block.timestamp) - stream.startTime;\n            uint128 streamed = ((stream.depositedShares * timeDelta) /\n                (stream.endTime - stream.startTime));\n            recipientBalance = streamed - stream.withdrawnShares;\n            senderBalance = stream.depositedShares - streamed;\n        }\n    }\n\n    function updateSender(uint256 streamId, address sender) external override {\n        Stream storage stream = streams[streamId];\n        if (msg.sender != stream.sender) revert NotSender();\n        stream.sender = sender;\n    }\n\n    function updateStream(\n        uint256 streamId,\n        uint128 topUpAmount,\n        uint64 extendTime,\n        bool fromBentoBox\n    ) external payable override returns (uint256 depositedShares) {\n        Stream storage stream = streams[streamId];\n        if (msg.sender != stream.sender) revert NotSender();\n\n        depositedShares = _depositToken(\n            stream.token,\n            stream.sender,\n            address(this),\n            topUpAmount,\n            fromBentoBox\n        );\n\n        address recipient = ownerOf[streamId];\n\n        (uint256 senderBalance, uint256 recipientBalance) = _streamBalanceOf(\n            stream\n        );\n\n        stream.startTime = uint64(block.timestamp);\n        stream.withdrawnShares = 0;\n        uint256 newDepositedShares = senderBalance + depositedShares;\n        if (newDepositedShares > type(uint128).max) revert Overflow();\n        stream.depositedShares = uint128(newDepositedShares);\n        stream.endTime += extendTime;\n\n        _transferToken(\n            stream.token,\n            address(this),\n            recipient,\n            recipientBalance,\n            true\n        );\n\n        emit UpdateStream(streamId, topUpAmount, extendTime, fromBentoBox);\n    }\n\n    function _depositToken(\n        address token,\n        address from,\n        address to,\n        uint256 amount,\n        bool fromBentoBox\n    ) internal returns (uint256 depositedShares) {\n        if (fromBentoBox) {\n            depositedShares = bentoBox.toShare(token, amount, false);\n            bentoBox.transfer(token, from, to, depositedShares);\n        } else {\n            (, depositedShares) = bentoBox.deposit{\n                value: token == address(0) ? amount : 0\n            }(token, from, to, amount, 0);\n        }\n    }\n\n    function _transferToken(\n        address token,\n        address from,\n        address to,\n        uint256 share,\n        bool toBentoBox\n    ) internal {\n        if (toBentoBox) {\n            bentoBox.transfer(token, from, to, share);\n        } else {\n            bentoBox.withdraw(token, from, to, 0, share);\n        }\n    }\n}\n"
    },
    "contracts/base/FuroVesting.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.10;\n\nimport \"../interfaces/IFuroVesting.sol\";\n\n// Use the FuroStreamVesting to create Vesting and do not create vesting directly.\n\n\ncontract FuroVesting is\n    IFuroVesting,\n    ERC721(\"Furo Vesting\", \"FUROVEST\"),\n    Multicall,\n    BoringOwnable\n{\n    IBentoBoxMinimal public immutable bentoBox;\n    address public immutable wETH;\n\n    address public tokenURIFetcher;\n\n    mapping(uint256 => Vest) public vests;\n\n    uint256 public vestIds;\n\n    uint256 public constant PERCENTAGE_PRECISION = 1e18;\n\n    // custom errors\n    error InvalidStart();\n    error NotOwner();\n    error NotVestReceiver();\n    error InvalidStepSetting();\n\n    constructor(IBentoBoxMinimal _bentoBox, address _wETH) {\n        bentoBox = _bentoBox;\n        wETH = _wETH;\n        vestIds = 1;\n        _bentoBox.registerProtocol();\n    }\n\n    function setTokenURIFetcher(address _fetcher) external onlyOwner {\n        tokenURIFetcher = _fetcher;\n    }\n\n    function tokenURI(uint256 id) public view override returns (string memory) {\n        return ITokenURIFetcher(tokenURIFetcher).fetchTokenURIData(id);\n    }\n\n    function setBentoBoxApproval(\n        address user,\n        bool approved,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable override {\n        bentoBox.setMasterContractApproval(\n            user,\n            address(this),\n            approved,\n            v,\n            r,\n            s\n        );\n    }\n\n    function createVesting(VestParams calldata vestParams)\n        external\n        payable\n        override\n        returns (\n            uint256 depositedShares,\n            uint256 vestId,\n            uint128 stepShares,\n            uint128 cliffShares\n        )\n    {\n        if (vestParams.start < block.timestamp) revert InvalidStart();\n        if (vestParams.stepPercentage > PERCENTAGE_PRECISION)\n            revert InvalidStepSetting();\n        if (vestParams.stepDuration == 0 || vestParams.steps == 0)\n            revert InvalidStepSetting();\n\n        depositedShares = _depositToken(\n            address(vestParams.token),\n            msg.sender,\n            address(this),\n            vestParams.amount,\n            vestParams.fromBentoBox\n        );\n        stepShares = uint128(\n            (vestParams.stepPercentage * depositedShares) / PERCENTAGE_PRECISION\n        );\n        cliffShares = uint128(\n            depositedShares - (stepShares * vestParams.steps)\n        );\n\n        vestId = vestIds++;\n        _mint(vestParams.recipient, vestId);\n\n        vests[vestId] = Vest({\n            owner: msg.sender,\n            token: address(vestParams.token) == address(0)\n                ? IERC20(wETH)\n                : vestParams.token,\n            start: vestParams.start,\n            cliffDuration: vestParams.cliffDuration,\n            stepDuration: vestParams.stepDuration,\n            steps: vestParams.steps,\n            cliffShares: cliffShares,\n            stepShares: stepShares,\n            claimed: 0\n        });\n\n        emit CreateVesting(\n            vestId,\n            vestParams.token,\n            msg.sender,\n            vestParams.recipient,\n            vestParams.start,\n            vestParams.cliffDuration,\n            vestParams.stepDuration,\n            vestParams.steps,\n            cliffShares,\n            stepShares,\n            vestParams.fromBentoBox\n        );\n    }\n\n    function withdraw(\n        uint256 vestId,\n        bytes calldata taskData,\n        bool toBentoBox\n    ) external override {\n        Vest storage vest = vests[vestId];\n        address recipient = ownerOf[vestId];\n        if (recipient != msg.sender) revert NotVestReceiver();\n        uint256 canClaim = _balanceOf(vest) - vest.claimed;\n\n        if (canClaim == 0) return;\n\n        vest.claimed += uint128(canClaim);\n\n        _transferToken(\n            address(vest.token),\n            address(this),\n            recipient,\n            canClaim,\n            toBentoBox\n        );\n\n        if (taskData.length != 0) ITasker(recipient).onTaskReceived(taskData);\n\n        emit Withdraw(vestId, vest.token, canClaim, toBentoBox);\n    }\n\n    function stopVesting(uint256 vestId, bool toBentoBox) external override {\n        Vest memory vest = vests[vestId];\n\n        if (vest.owner != msg.sender) revert NotOwner();\n\n        uint256 amountVested = _balanceOf(vest);\n        uint256 canClaim = amountVested - vest.claimed;\n        uint256 returnShares = (vest.cliffShares +\n            (vest.steps * vest.stepShares)) - amountVested;\n\n        delete vests[vestId];\n\n        _transferToken(\n            address(vest.token),\n            address(this),\n            ownerOf[vestId],\n            canClaim,\n            toBentoBox\n        );\n\n        _transferToken(\n            address(vest.token),\n            address(this),\n            msg.sender,\n            returnShares,\n            toBentoBox\n        );\n        emit CancelVesting(\n            vestId,\n            returnShares,\n            canClaim,\n            vest.token,\n            toBentoBox\n        );\n    }\n\n    function vestBalance(uint256 vestId)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        Vest memory vest = vests[vestId];\n        return _balanceOf(vest) - vest.claimed;\n    }\n\n    function _balanceOf(Vest memory vest)\n        internal\n        view\n        returns (uint256 claimable)\n    {\n        uint256 timeAfterCliff = vest.start + vest.cliffDuration;\n\n        if (block.timestamp < timeAfterCliff) {\n            return claimable;\n        }\n\n        uint256 passedSinceCliff = block.timestamp - timeAfterCliff;\n\n        uint256 stepPassed = Math.min(\n            vest.steps,\n            passedSinceCliff / vest.stepDuration\n        );\n\n        claimable = vest.cliffShares + (vest.stepShares * stepPassed);\n    }\n\n    function updateOwner(uint256 vestId, address newOwner) external override {\n        Vest storage vest = vests[vestId];\n        if (vest.owner != msg.sender) revert NotOwner();\n        vest.owner = newOwner;\n        emit LogUpdateOwner(vestId, newOwner);\n    }\n\n    function _depositToken(\n        address token,\n        address from,\n        address to,\n        uint256 amount,\n        bool fromBentoBox\n    ) internal returns (uint256 depositedShares) {\n        if (fromBentoBox) {\n            depositedShares = bentoBox.toShare(token, amount, false);\n            bentoBox.transfer(token, from, to, depositedShares);\n        } else {\n            (, depositedShares) = bentoBox.deposit{\n                value: token == address(0) ? amount : 0\n            }(token, from, to, amount, 0);\n        }\n    }\n\n    function _transferToken(\n        address token,\n        address from,\n        address to,\n        uint256 shares,\n        bool toBentoBox\n    ) internal {\n        if (toBentoBox) {\n            bentoBox.transfer(token, from, to, shares);\n        } else {\n            bentoBox.withdraw(token, from, to, 0, shares);\n        }\n    }\n}\n"
    },
    "contracts/FuroStreamRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.10;\n\nimport './interfaces/IFuroStream.sol';\n\ncontract FuroStreamRouter is Multicall {\n  IBentoBoxMinimal public immutable bentoBox;\n  IFuroStream public immutable furoStream;\n  address public immutable wETH;\n\n  // custom errors\n  error InsufficientShares();\n\n  constructor(\n    IBentoBoxMinimal _bentoBox,\n    IFuroStream _furoStream,\n    address _wETH\n  ) {\n    bentoBox = _bentoBox;\n    furoStream = _furoStream;\n    wETH = _wETH;\n    _bentoBox.setMasterContractApproval(address(this), address(_furoStream), true, 0, bytes32(0), bytes32(0));\n    _bentoBox.registerProtocol();\n  }\n\n  function setBentoBoxApproval(\n    address user,\n    bool approved,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external payable {\n    bentoBox.setMasterContractApproval(user, address(this), approved, v, r, s);\n  }\n\n  function createStream(\n    address recipient,\n    address token,\n    uint64 startTime,\n    uint64 endTime,\n    uint256 amount, /// @dev in token amount and not in shares\n    bool fromBentoBox,\n    uint256 minShare\n  ) external payable returns (uint256 streamId, uint256 depositedShares) {\n    depositedShares = _depositToken(token, msg.sender, address(this), amount, fromBentoBox);\n\n    if (depositedShares < minShare) revert InsufficientShares();\n\n    (streamId, ) = furoStream.createStream(\n      recipient,\n      token == address(0) ? wETH : token,\n      startTime,\n      endTime,\n      amount,\n      true\n    );\n\n    furoStream.updateSender(streamId, msg.sender);\n  }\n\n  function _depositToken(\n    address token,\n    address from,\n    address to,\n    uint256 amount,\n    bool fromBentoBox\n  ) internal returns (uint256 depositedShares) {\n    if (fromBentoBox) {\n      depositedShares = bentoBox.toShare(token, amount, false);\n      bentoBox.transfer(token, from, to, depositedShares);\n    } else {\n      (, depositedShares) = bentoBox.deposit{value: token == address(0) ? amount : 0}(token, from, to, amount, 0);\n    }\n  }\n}\n"
    },
    "contracts/FuroVestingRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.10;\n\nimport './interfaces/IFuroVesting.sol';\n\ncontract FuroVestingRouter is Multicall {\n  IBentoBoxMinimal public immutable bentoBox;\n  IFuroVesting public immutable furoVesting;\n  address public immutable wETH;\n\n  // custom errors\n  error InsufficientShares();\n\n  constructor(\n    IBentoBoxMinimal _bentoBox,\n    IFuroVesting _furoVesting,\n    address _wETH\n  ) {\n    bentoBox = _bentoBox;\n    furoVesting = _furoVesting;\n    wETH = _wETH;\n    _bentoBox.setMasterContractApproval(address(this), address(_furoVesting), true, 0, bytes32(0), bytes32(0));\n    _bentoBox.registerProtocol();\n  }\n\n  function setBentoBoxApproval(\n    address user,\n    bool approved,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external payable {\n    bentoBox.setMasterContractApproval(user, address(this), approved, v, r, s);\n  }\n\n  function createVesting(IFuroVesting.VestParams memory vestParams, uint256 minShare)\n    external\n    payable\n    returns (\n      uint256 depositedShares,\n      uint256 vestId,\n      uint128 stepShares,\n      uint128 cliffShares\n    )\n  {\n    depositedShares = _depositToken(\n      address(vestParams.token),\n      msg.sender,\n      address(this),\n      vestParams.amount,\n      vestParams.fromBentoBox\n    );\n\n    if (depositedShares < minShare) revert InsufficientShares();\n\n    if (address(vestParams.token) == address(0)) {\n      vestParams.token = IERC20(wETH);\n    }\n    vestParams.fromBentoBox = true;\n\n    (depositedShares, vestId, stepShares, cliffShares) = furoVesting.createVesting(vestParams);\n\n    furoVesting.updateOwner(vestId, msg.sender);\n  }\n\n  function _depositToken(\n    address token,\n    address from,\n    address to,\n    uint256 amount,\n    bool fromBentoBox\n  ) internal returns (uint256 depositedShares) {\n    if (fromBentoBox) {\n      depositedShares = bentoBox.toShare(token, amount, false);\n      bentoBox.transfer(token, from, to, depositedShares);\n    } else {\n      (, depositedShares) = bentoBox.deposit{value: token == address(0) ? amount : 0}(token, from, to, amount, 0);\n    }\n  }\n}\n"
    },
    "contracts/interfaces/IBentoBoxMinimal.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.10;\n\n/// @notice Minimal BentoBox vault interface.\n/// @dev `token` is aliased as `address` from `IERC20` for simplicity.\ninterface IBentoBoxMinimal {\n    /// @notice Balance per ERC-20 token per account in shares.\n    function balanceOf(address, address) external view returns (uint256);\n\n    /// @dev Helper function to represent an `amount` of `token` in shares.\n    /// @param token The ERC-20 token.\n    /// @param amount The `token` amount.\n    /// @param roundUp If the result `share` should be rounded up.\n    /// @return share The token amount represented in shares.\n    function toShare(\n        address token,\n        uint256 amount,\n        bool roundUp\n    ) external view returns (uint256 share);\n\n    /// @dev Helper function to represent shares back into the `token` amount.\n    /// @param token The ERC-20 token.\n    /// @param share The amount of shares.\n    /// @param roundUp If the result should be rounded up.\n    /// @return amount The share amount back into native representation.\n    function toAmount(\n        address token,\n        uint256 share,\n        bool roundUp\n    ) external view returns (uint256 amount);\n\n    /// @notice Registers this contract so that users can approve it for BentoBox.\n    function registerProtocol() external;\n\n    /// @notice Deposit an amount of `token` represented in either `amount` or `share`.\n    /// @param token_ The ERC-20 token to deposit.\n    /// @param from which account to pull the tokens.\n    /// @param to which account to push the tokens.\n    /// @param amount Token amount in native representation to deposit.\n    /// @param share Token amount represented in shares to deposit. Takes precedence over `amount`.\n    /// @return amountOut The amount deposited.\n    /// @return shareOut The deposited amount represented in shares.\n    function deposit(\n        address token_,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external payable returns (uint256 amountOut, uint256 shareOut);\n\n    /// @notice Withdraws an amount of `token` from a user account.\n    /// @param token_ The ERC-20 token to withdraw.\n    /// @param from which user to pull the tokens.\n    /// @param to which user to push the tokens.\n    /// @param amount of tokens. Either one of `amount` or `share` needs to be supplied.\n    /// @param share Like above, but `share` takes precedence over `amount`.\n    function withdraw(\n        address token_,\n        address from,\n        address to,\n        uint256 amount,\n        uint256 share\n    ) external returns (uint256 amountOut, uint256 shareOut);\n\n    /// @notice Transfer shares from a user account to another one.\n    /// @param token The ERC-20 token to transfer.\n    /// @param from which user to pull the tokens.\n    /// @param to which user to push the tokens.\n    /// @param share The amount of `token` in shares.\n    function transfer(\n        address token,\n        address from,\n        address to,\n        uint256 share\n    ) external;\n\n    function setMasterContractApproval(\n        address user,\n        address masterContract,\n        bool approved,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.10;\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    /// @notice EIP 2612\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "contracts/interfaces/IFuroStream.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.10;\n\nimport \"./ITasker.sol\";\nimport \"./ITokenURIFetcher.sol\";\nimport \"./IBentoBoxMinimal.sol\";\nimport \"../utils/Multicall.sol\";\nimport \"../utils/BoringOwnable.sol\";\nimport \"@rari-capital/solmate/src/tokens/ERC721.sol\";\n\ninterface IFuroStream {\n    function setBentoBoxApproval(\n        address user,\n        bool approved,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable;\n\n    function createStream(\n        address recipient,\n        address token,\n        uint64 startTime,\n        uint64 endTime,\n        uint256 amount, /// @dev in token amount and not in shares\n        bool fromBento\n    ) external payable returns (uint256 streamId, uint256 depositedShares);\n\n    function withdrawFromStream(\n        uint256 streamId,\n        uint256 sharesToWithdraw,\n        address withdrawTo,\n        bool toBentoBox,\n        bytes memory taskData\n    ) external returns (uint256 recipientBalance, address to);\n\n    function cancelStream(uint256 streamId, bool toBentoBox)\n        external\n        returns (uint256 senderBalance, uint256 recipientBalance);\n\n    function updateSender(uint256 streamId, address sender) external;\n\n    function updateStream(\n        uint256 streamId,\n        uint128 topUpAmount,\n        uint64 extendTime,\n        bool fromBentoBox\n    ) external payable returns (uint256 depositedShares);\n\n    function streamBalanceOf(uint256 streamId)\n        external\n        view\n        returns (uint256 senderBalance, uint256 recipientBalance);\n\n    function getStream(uint256 streamId) external view returns (Stream memory);\n\n    event CreateStream(\n        uint256 indexed streamId,\n        address indexed sender,\n        address indexed recipient,\n        address token,\n        uint256 amount,\n        uint256 startTime,\n        uint256 endTime,\n        bool fromBentoBox\n    );\n\n    event UpdateStream(\n        uint256 indexed streamId,\n        uint128 indexed topUpAmount,\n        uint64 indexed extendTime,\n        bool fromBentoBox\n    );\n\n    event Withdraw(\n        uint256 indexed streamId,\n        uint256 indexed sharesToWithdraw,\n        address indexed withdrawTo,\n        address token,\n        bool toBentoBox\n    );\n\n    event CancelStream(\n        uint256 indexed streamId,\n        uint256 indexed senderBalance,\n        uint256 indexed recipientBalance,\n        address token,\n        bool toBentoBox\n    );\n\n    struct Stream {\n        address sender;\n        address token;\n        uint128 depositedShares;\n        uint128 withdrawnShares;\n        uint64 startTime;\n        uint64 endTime;\n    }\n}\n"
    },
    "contracts/interfaces/IFuroVesting.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.10;\n\nimport \"./ITasker.sol\";\nimport \"./IERC20.sol\";\nimport \"./ITokenURIFetcher.sol\";\nimport \"./IBentoBoxMinimal.sol\";\nimport \"../utils/Multicall.sol\";\nimport \"../utils/BoringOwnable.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@rari-capital/solmate/src/tokens/ERC721.sol\";\n\ninterface IFuroVesting {\n    function setBentoBoxApproval(\n        address user,\n        bool approved,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable;\n\n    function createVesting(VestParams calldata vestParams)\n        external\n        payable\n        returns (\n            uint256 depositedShares,\n            uint256 vestId,\n            uint128 stepShares,\n            uint128 cliffShares\n        );\n\n    function withdraw(\n        uint256 vestId,\n        bytes memory taskData,\n        bool toBentoBox\n    ) external;\n\n    function stopVesting(uint256 vestId, bool toBentoBox) external;\n\n    function vestBalance(uint256 vestId) external view returns (uint256);\n\n    function updateOwner(uint256 vestId, address newOwner) external;\n\n    struct VestParams {\n        IERC20 token;\n        address recipient;\n        uint32 start;\n        uint32 cliffDuration;\n        uint32 stepDuration;\n        uint32 steps;\n        uint128 stepPercentage;\n        uint128 amount;\n        bool fromBentoBox;\n    }\n\n    struct Vest {\n        address owner;\n        IERC20 token;\n        uint32 start;\n        uint32 cliffDuration;\n        uint32 stepDuration;\n        uint32 steps;\n        uint128 cliffShares;\n        uint128 stepShares;\n        uint128 claimed;\n    }\n\n    event CreateVesting(\n        uint256 indexed vestId,\n        IERC20 token,\n        address indexed owner,\n        address indexed recipient,\n        uint32 start,\n        uint32 cliffDuration,\n        uint32 stepDuration,\n        uint32 steps,\n        uint128 cliffShares,\n        uint128 stepShares,\n        bool fromBentoBox\n    );\n\n    event Withdraw(\n        uint256 indexed vestId,\n        IERC20 indexed token,\n        uint256 indexed amount,\n        bool toBentoBox\n    );\n\n    event CancelVesting(\n        uint256 indexed vestId,\n        uint256 indexed ownerAmount,\n        uint256 indexed recipientAmount,\n        IERC20 token,\n        bool toBentoBox\n    );\n\n    event LogUpdateOwner(uint256 indexed vestId, address indexed newOwner);\n}\n"
    },
    "contracts/interfaces/ITasker.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.10;\n\ninterface ITasker {\n    function onTaskReceived(\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/interfaces/ITokenURIFetcher.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.10;\n\ninterface ITokenURIFetcher {\n    function fetchTokenURIData(uint256 id)\n        external\n        view\n        returns (string memory);\n}\n"
    },
    "contracts/libraries/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.12;\n\nimport \"../interfaces/IERC20.sol\";\n\nlibrary SafeERC20 {\n    function safeSymbol(IERC20 token) internal view returns (string memory) {\n        (bool success, bytes memory data) = address(token).staticcall(\n            abi.encodeWithSelector(0x95d89b41)\n        );\n        return success && data.length > 0 ? abi.decode(data, (string)) : \"???\";\n    }\n\n    function safeName(IERC20 token) internal view returns (string memory) {\n        (bool success, bytes memory data) = address(token).staticcall(\n            abi.encodeWithSelector(0x06fdde03)\n        );\n        return success && data.length > 0 ? abi.decode(data, (string)) : \"???\";\n    }\n\n    function safeDecimals(IERC20 token) public view returns (uint8) {\n        (bool success, bytes memory data) = address(token).staticcall(\n            abi.encodeWithSelector(0x313ce567)\n        );\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\n    }\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSelector(0xa9059cbb, to, amount)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"SafeERC20: Transfer failed\"\n        );\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        uint256 amount\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(\n            abi.encodeWithSelector(0x23b872dd, from, address(this), amount)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"SafeERC20: TransferFrom failed\"\n        );\n    }\n}\n"
    },
    "contracts/libraries/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.6.12;\n\n// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)\n\nlibrary SafeMathUniswap {\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x, \"ds-math-add-overflow\");\n    }\n\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x, \"ds-math-sub-underflow\");\n    }\n\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n    }\n}\n"
    },
    "contracts/libraries/UniswapV2Library.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity >=0.5.0;\n\nimport \"@sushiswap/core/contracts/uniswapv2/interfaces/IUniswapV2Pair.sol\";\n\nimport \"./SafeMath.sol\";\n\nlibrary UniswapV2Library {\n    using SafeMathUniswap for uint256;\n\n    // returns sorted token addresses, used to handle return values from pairs sorted in this order\n    function sortTokens(address tokenA, address tokenB)\n        internal\n        pure\n        returns (address token0, address token1)\n    {\n        require(tokenA != tokenB, \"UniswapV2Library: IDENTICAL_ADDRESSES\");\n        (token0, token1) = tokenA < tokenB\n            ? (tokenA, tokenB)\n            : (tokenB, tokenA);\n        require(token0 != address(0), \"UniswapV2Library: ZERO_ADDRESS\");\n    }\n\n    // calculates the CREATE2 address for a pair without making any external calls\n    function pairFor(\n        address factory,\n        address tokenA,\n        address tokenB,\n        bytes32 pairCodeHash\n    ) internal pure returns (address pair) {\n        (address token0, address token1) = sortTokens(tokenA, tokenB);\n        pair = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            hex\"ff\",\n                            factory,\n                            keccak256(abi.encodePacked(token0, token1)),\n                            pairCodeHash // init code hash\n                        )\n                    )\n                )\n            )\n        );\n    }\n\n    // fetches and sorts the reserves for a pair\n    function getReserves(\n        address factory,\n        address tokenA,\n        address tokenB,\n        bytes32 pairCodeHash\n    ) internal view returns (uint256 reserveA, uint256 reserveB) {\n        (address token0, ) = sortTokens(tokenA, tokenB);\n        (uint256 reserve0, uint256 reserve1, ) = IUniswapV2Pair(\n            pairFor(factory, tokenA, tokenB, pairCodeHash)\n        ).getReserves();\n        (reserveA, reserveB) = tokenA == token0\n            ? (reserve0, reserve1)\n            : (reserve1, reserve0);\n    }\n\n    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\n    function quote(\n        uint256 amountA,\n        uint256 reserveA,\n        uint256 reserveB\n    ) internal pure returns (uint256 amountB) {\n        require(amountA > 0, \"UniswapV2Library: INSUFFICIENT_AMOUNT\");\n        require(\n            reserveA > 0 && reserveB > 0,\n            \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\n        );\n        amountB = amountA.mul(reserveB) / reserveA;\n    }\n\n    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset\n    function getAmountOut(\n        uint256 amountIn,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountOut) {\n        require(amountIn > 0, \"UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT\");\n        require(\n            reserveIn > 0 && reserveOut > 0,\n            \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\n        );\n        uint256 amountInWithFee = amountIn.mul(997);\n        uint256 numerator = amountInWithFee.mul(reserveOut);\n        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);\n        amountOut = numerator / denominator;\n    }\n\n    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset\n    function getAmountIn(\n        uint256 amountOut,\n        uint256 reserveIn,\n        uint256 reserveOut\n    ) internal pure returns (uint256 amountIn) {\n        require(amountOut > 0, \"UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT\");\n        require(\n            reserveIn > 0 && reserveOut > 0,\n            \"UniswapV2Library: INSUFFICIENT_LIQUIDITY\"\n        );\n        uint256 numerator = reserveIn.mul(amountOut).mul(1000);\n        uint256 denominator = reserveOut.sub(amountOut).mul(997);\n        amountIn = (numerator / denominator).add(1);\n    }\n\n    // performs chained getAmountOut calculations on any number of pairs\n    function getAmountsOut(\n        address factory,\n        uint256 amountIn,\n        address[] memory path,\n        bytes32 pairCodeHash\n    ) internal view returns (uint256[] memory amounts) {\n        require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\n        amounts = new uint256[](path.length);\n        amounts[0] = amountIn;\n        for (uint256 i; i < path.length - 1; i++) {\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(\n                factory,\n                path[i],\n                path[i + 1],\n                pairCodeHash\n            );\n            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);\n        }\n    }\n\n    // performs chained getAmountIn calculations on any number of pairs\n    function getAmountsIn(\n        address factory,\n        uint256 amountOut,\n        address[] memory path,\n        bytes32 pairCodeHash\n    ) internal view returns (uint256[] memory amounts) {\n        require(path.length >= 2, \"UniswapV2Library: INVALID_PATH\");\n        amounts = new uint256[](path.length);\n        amounts[amounts.length - 1] = amountOut;\n        for (uint256 i = path.length - 1; i > 0; i--) {\n            (uint256 reserveIn, uint256 reserveOut) = getReserves(\n                factory,\n                path[i - 1],\n                path[i],\n                pairCodeHash\n            );\n            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);\n        }\n    }\n}\n"
    },
    "contracts/mock/ERC20Mock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract ERC20Mock is ERC20 {\n    event Deposit(address indexed dst, uint256 wad);\n    event Withdrawal(address indexed src, uint256 wad);\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint256 supply\n    ) ERC20(name, symbol) {\n        _mint(msg.sender, supply);\n    }\n\n    receive() external payable {\n        deposit();\n    }\n\n    function deposit() public payable {\n        _mint(msg.sender, msg.value);\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function withdraw(uint256 wad) public {\n        _burn(msg.sender, wad);\n        payable(msg.sender).transfer(wad);\n        emit Withdrawal(msg.sender, wad);\n    }\n}\n"
    },
    "contracts/mock/TaskReceiverMock.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity 0.8.10;\n\nimport \"../interfaces/ITasker.sol\";\n\ncontract TaskReceiverMock is ITasker {\n\n    function onTaskReceived(bytes memory taskData) external override {\n        \n    }\n\n}"
    },
    "contracts/utils/BoringOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.12;\n\n// Audit on 5-Jan-2021 by Keno and BoringCrypto\n// Source: https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol + Claimable.sol\n// Edited by BoringCrypto\n\ncontract BoringOwnableData {\n    address public owner;\n    address public pendingOwner;\n}\n\ncontract BoringOwnable is BoringOwnableData {\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /// @notice `owner` defaults to msg.sender on construction.\n    constructor() {\n        owner = msg.sender;\n        emit OwnershipTransferred(address(0), msg.sender);\n    }\n\n    /// @notice Transfers ownership to `newOwner`. Either directly or claimable by the new pending owner.\n    /// Can only be invoked by the current `owner`.\n    /// @param newOwner Address of the new owner.\n    /// @param direct True if `newOwner` should be set immediately. False if `newOwner` needs to use `claimOwnership`.\n    /// @param renounce Allows the `newOwner` to be `address(0)` if `direct` and `renounce` is True. Has no effect otherwise.\n    function transferOwnership(\n        address newOwner,\n        bool direct,\n        bool renounce\n    ) public onlyOwner {\n        if (direct) {\n            // Checks\n            require(\n                newOwner != address(0) || renounce,\n                \"Ownable: zero address\"\n            );\n\n            // Effects\n            emit OwnershipTransferred(owner, newOwner);\n            owner = newOwner;\n            pendingOwner = address(0);\n        } else {\n            // Effects\n            pendingOwner = newOwner;\n        }\n    }\n\n    /// @notice Needs to be called by `pendingOwner` to claim ownership.\n    function claimOwnership() public {\n        address _pendingOwner = pendingOwner;\n\n        // Checks\n        require(\n            msg.sender == _pendingOwner,\n            \"Ownable: caller != pending owner\"\n        );\n\n        // Effects\n        emit OwnershipTransferred(owner, _pendingOwner);\n        owner = _pendingOwner;\n        pendingOwner = address(0);\n    }\n\n    /// @notice Only allows the `owner` to execute the function.\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Ownable: caller is not the owner\");\n        _;\n    }\n}\n"
    },
    "contracts/utils/Multicall.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.10;\n\n/// @title Multicall\n/// @notice Enables calling multiple methods in a single call to the contract\nabstract contract Multicall {\n    function multicall(bytes[] calldata data)\n        public\n        payable\n        returns (bytes[] memory results)\n    {\n        results = new bytes[](data.length);\n        for (uint256 i = 0; i < data.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(\n                data[i]\n            );\n\n            if (!success) {\n                // Next 5 lines from https://ethereum.stackexchange.com/a/83577\n                if (result.length < 68) revert();\n                assembly {\n                    result := add(result, 0x04)\n                }\n                revert(abi.decode(result, (string)));\n            }\n\n            results[i] = result;\n        }\n    }\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 999999
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}